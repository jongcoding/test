# .github/workflows/cd.yml
name: CD – Build, Push & Deploy to GCE

on:
  push:
    branches: [ main ]
    tags:     [ 'v*.*.*' ]

jobs:
  # ────────────────────────────────
  # 1) Build & Push
  # ────────────────────────────────
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag:    ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/myflask
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build & Push image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags:   ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to:   type=gha,mode=max

  # ────────────────────────────────
  # 2) Deploy to GCE VM
  # ────────────────────────────────
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      REMOTE_DIR:        ${{ secrets.REMOTE_APP_DIR }}
      DOMAIN:            ${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      IMAGE_TAG:         ${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.GCP_SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H ${{ secrets.GCP_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          if [ -n "${{ secrets.GCP_HOST_KEY }}" ]; then
            echo "${{ secrets.GCP_HOST_KEY }}" >> ~/.ssh/known_hosts
          fi

      - name: Test SSH
        run: |
          ssh -o ConnectTimeout=10 ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "echo OK"

      # ① 디렉터리 준비
      - name: Prepare directories on VM
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} <<EOF
          mkdir -p "${{ env.REMOTE_DIR }}"/{nginx,certbot/{config,www,logs}}
          EOF

      # ② .env 파일 작성
      - name: Upload .env
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} <<EOF
          cat > "${{ env.REMOTE_DIR }}/.env" <<EOT
          DOMAIN=${{ env.DOMAIN }}
          LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}
          IMAGE_TAG=${{ env.IMAGE_TAG }}
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          EOT
          EOF

      # ③ Compose & Nginx 템플릿 전송
      - name: Upload compose / nginx template
        run: |
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml \
              ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"${{ env.REMOTE_DIR }}/"
          scp -o StrictHostKeyChecking=no nginx/default.conf.template \
              ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"${{ env.REMOTE_DIR }}/nginx/"

      # ④ 기존 컨테이너 정리
      - name: Clean old containers
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yml down --remove-orphans || true &&
            docker system prune -f --volumes || true
          "

      # ⑤ Nginx & Web (HTTP) 시작
      - name: Start nginx & web
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yml pull web nginx &&
            docker compose -f docker-compose.prod.yml up -d nginx web
          "

      # ⑥ HTTP 준비 대기
      - name: Wait for HTTP
        run: |
          for i in {1..24}; do
            curl -sSf -m 5 http://${{ env.DOMAIN }} >/dev/null && echo 'HTTP OK' && break
            echo "…waiting ($i/24)"; sleep 5
          done

      # ⑦ Certbot (webroot, 컨테이너 사용)
      - name: Issue / Renew SSL
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose run --rm certbot \
              certonly --webroot -w /var/www/certbot \
              --email '${{ env.LETSENCRYPT_EMAIL }}' -d '${{ env.DOMAIN }}' \
              --agree-tos --no-eff-email --rsa-key-size 4096
          "

      # ⑧ 전체 스택(HTTPS 포함) 재시작
      - name: Deploy latest stack
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yml pull &&
            docker compose -f docker-compose.prod.yml up -d --remove-orphans
          "

      # ⑨ 검증
      - name: Verify HTTPS
        run: |
          for i in {1..12}; do
            curl -sSf -m 5 https://${{ env.DOMAIN }} >/dev/null && echo 'HTTPS OK' && break
            echo "…waiting HTTPS ($i/12)"; sleep 10
          done

      # ⑩ 오래된 이미지 정리
      - name: Prune images
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "docker image prune -f --filter 'until=24h' || true"

  # ────────────────────────────────
  # 3) Notification
  # ────────────────────────────────
  notify:
    needs: [build-and-push, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Success notice
        if: success()
        run: echo "✅ Deployed to ${{ secrets.DOMAIN }}"

      - name: Failure notice
        if: failure()
        run: echo "❌ Deployment to ${{ secrets.DOMAIN }} failed"
