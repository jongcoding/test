# .github/workflows/cd.yml
name: CD â€“ Build, Push & Deploy to GCE

on:
  push:
    branches: [ main ]
    tags:     [ 'v*.*.*' ]

jobs:
  # 1) ì´ë¯¸ì§€ ë¹Œë“œ & Docker Hub í‘¸ì‹œ
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker Hub ë¡œê·¸ì¸
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/myflask
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ì´ë¯¸ì§€ ë¹Œë“œ & í‘¸ì‹œ
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 2) GCE VM ë°°í¬ + ì¸ì¦ì„œ ë°œê¸‰
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      REMOTE_APP_DIR: ${{ secrets.REMOTE_APP_DIR }}
      DOMAIN: ${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      # SSH ì¤€ë¹„
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.GCP_SSH_KEY }}

      - name: Add GCE host to known_hosts
        run: |
          ssh-keyscan -H ${{ secrets.GCP_HOST }} >> ~/.ssh/known_hosts
          # ì¶”ê°€ ë³´ì•ˆì„ ìœ„í•œ host key ê²€ì¦
          if [ -n "${{ secrets.GCP_HOST_KEY }}" ]; then
            echo "${{ secrets.GCP_HOST_KEY }}" >> ~/.ssh/known_hosts
          fi

      # ì—°ê²° í…ŒìŠ¤íŠ¸
      - name: Test SSH connection
        run: |
          ssh -o ConnectTimeout=10 ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "echo 'SSH connection successful'"

      # ì›ê²© í´ë” êµ¬ì¡° ìƒì„±
      - name: Ensure remote directory structure
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             echo 'Creating directories in: \$REMOTE_APP_DIR' && \
             mkdir -p \"\$REMOTE_APP_DIR\" \
                      \"\$REMOTE_APP_DIR/nginx\" \
                      \"\$REMOTE_APP_DIR/certbot/config\" \
                      \"\$REMOTE_APP_DIR/certbot/www\" \
                      \"\$REMOTE_APP_DIR/certbot/logs\" && \
             echo 'Directory structure created successfully' && \
             ls -la \"\$REMOTE_APP_DIR\""

      # .env íŒŒì¼ ì‘ì„± (í™˜ê²½ë³€ìˆ˜ ì „ë‹¬ ìˆ˜ì •)
      - name: Write .env on VM
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cat > \"\$REMOTE_APP_DIR/.env\" << 'DOTENV'
          DOMAIN=${{ secrets.DOMAIN }}
          LETSENCRYPT_EMAIL=${{ secrets.LETSENCRYPT_EMAIL }}
          IMAGE_TAG=${{ github.sha }}
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          DOTENV
          echo '.env file created successfully' && \
          cat \"\$REMOTE_APP_DIR/.env\""

      # í”„ë¡œë•ì…˜ìš© Compose & Nginx í…œí”Œë¦¿ ì „ì†¡
      - name: Copy production assets to VM
        run: |
          export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}'
          scp docker-compose.prod.yml \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"$REMOTE_APP_DIR/"
          scp nginx/default.conf.template \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"$REMOTE_APP_DIR/nginx/"

      # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ì •ë¦¬ (ì„ íƒì )
      - name: Clean up old containers
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             docker compose -f docker-compose.prod.yml down --remove-orphans || true && \
             docker system prune -f --volumes || true"

      # â‘  Nginx + Web ì„ ê¸°ë™ (HTTP 80 í¬íŠ¸ ì—´ê¸°)
      - name: Start nginx & web (HTTP only)
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             source .env && \
             docker compose -f docker-compose.prod.yml pull web nginx && \
             docker compose -f docker-compose.prod.yml up -d nginx web"

      # â‘¡ Port 80 ì—°ê²° í™•ì¸ (ìµœëŒ€ 2ë¶„, ë” ê²¬ê³ í•œ ì²´í¬)
      - name: Wait until port 80 is reachable
        run: |
          echo "Waiting for HTTP service to be ready..."
          max_attempts=24
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            # ì—¬ëŸ¬ ì—”ë“œí¬ì¸íŠ¸ ì²´í¬
            if curl -sSf -m 10 --connect-timeout 5 http://${DOMAIN} >/dev/null 2>&1 || \
               curl -sSf -m 10 --connect-timeout 5 http://${DOMAIN}/.well-known/acme-challenge/ >/dev/null 2>&1; then
              echo "âœ… Port 80 is reachable (attempt $attempt)"
              break
            fi
            
            echo "â³ Waiting for port 80... (attempt $attempt/$max_attempts)"
            sleep 5
            attempt=$((attempt + 1))
            
            if [ $attempt -gt $max_attempts ]; then
              echo "âŒ Port 80 not reachable after 2 minutes"
              # ë””ë²„ê¹… ì •ë³´ ìˆ˜ì§‘
              ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
                "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
                 cd \"\$REMOTE_APP_DIR\" && \
                 docker compose -f docker-compose.prod.yml logs nginx web"
              exit 1
            fi
          done

      # â‘¢ Certbot(webroot) ì¸ì¦ì„œ ë°œê¸‰ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)
      - name: Issue / Renew SSL certificate
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             source .env && \
             echo 'ğŸ”’ Attempting to issue/renew SSL certificate...' && \
             max_cert_attempts=3
             cert_attempt=1
             
             while [ \$cert_attempt -le \$max_cert_attempts ]; do
               echo \"Certificate attempt \$cert_attempt/\$max_cert_attempts\"
               
               if docker compose -f docker-compose.prod.yml run --rm certbot \
                 certbot certonly --webroot -w /var/www/certbot \
                 --email \${LETSENCRYPT_EMAIL} \
                 -d \${DOMAIN} \
                 --agree-tos --no-eff-email --rsa-key-size 4096 \
                 --non-interactive --keep-until-expiring; then
                 echo 'âœ… SSL certificate obtained successfully'
                 break
               fi
               
               echo \"âŒ Certificate attempt \$cert_attempt failed\"
               cert_attempt=\$((cert_attempt + 1))
               
               if [ \$cert_attempt -le \$max_cert_attempts ]; then
                 echo 'â³ Retrying in 15 seconds...'
                 sleep 15
               else
                 echo 'âŒ All certificate attempts failed'
                 docker compose -f docker-compose.prod.yml logs certbot
                 exit 1
               fi
             done"

      # â‘£ ìµœì‹  ì´ë¯¸ì§€ pull & ì „ì²´ ìŠ¤íƒ ì¬ì‹œì‘ (HTTPS í¬í•¨)
      - name: Deploy with latest images
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             source .env && \
             echo 'ğŸš€ Pulling latest images...' && \
             docker compose -f docker-compose.prod.yml pull && \
             echo 'ğŸ”„ Restarting all services...' && \
             docker compose -f docker-compose.prod.yml up -d --remove-orphans && \
             echo 'âœ… Deployment completed successfully'"

      # â‘¤ ë°°í¬ í›„ ìƒíƒœ í™•ì¸
      - name: Verify deployment
        run: |
          echo "ğŸ” Verifying deployment..."
          
          # HTTPS ì²´í¬
          max_attempts=12
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -sSf -m 10 --connect-timeout 5 https://${DOMAIN} >/dev/null 2>&1; then
              echo "âœ… HTTPS service is working (attempt $attempt)"
              break
            fi
            
            echo "â³ Waiting for HTTPS service... (attempt $attempt/$max_attempts)"
            sleep 10
            attempt=$((attempt + 1))
            
            if [ $attempt -gt $max_attempts ]; then
              echo "âš ï¸  HTTPS not immediately available, checking logs..."
              ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
                "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
                 cd \"\$REMOTE_APP_DIR\" && \
                 docker compose -f docker-compose.prod.yml logs --tail=50"
              # HTTPS ì‹¤íŒ¨í•´ë„ ë°°í¬ëŠ” ì„±ê³µìœ¼ë¡œ ê°„ì£¼ (HTTPëŠ” ì‘ë™ ì¤‘)
              echo "â„¹ï¸  Deployment completed, but HTTPS may need more time"
              break
            fi
          done

      # â‘¥ ì •ë¦¬ ì‘ì—…
      - name: Cleanup old Docker images
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "docker image prune -f --filter 'until=24h' || true"

  # 3) ë°°í¬ ì•Œë¦¼ (ì„ íƒì‚¬í•­)
  notify:
    needs: [build-and-push, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send deployment notification
        if: success()
        run: |
          echo "âœ… Deployment to ${{ secrets.DOMAIN }} completed successfully!"
          # ì—¬ê¸°ì— Slack, Discord, ì´ë©”ì¼ ì•Œë¦¼ ë“±ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
          
      - name: Send failure notification
        if: failure()
        run: |
          echo "âŒ Deployment to ${{ secrets.DOMAIN }} failed!"
          # ì‹¤íŒ¨ ì•Œë¦¼ ë¡œì§