# .github/workflows/cd.yml
name: CD ‚Äì Build, Push & Deploy to GCE

on:
  push:
    branches: [ main ]
    tags:     [ 'v*.*.*' ]

jobs:
  # 1) Ïù¥ÎØ∏ÏßÄ ÎπåÎìú & Docker Hub Ìë∏Ïãú
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker Hub Î°úÍ∑∏Ïù∏
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/myflask
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Ïù¥ÎØ∏ÏßÄ ÎπåÎìú & Ìë∏Ïãú
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 2) GCE VM Î∞∞Ìè¨ + Ïù∏Ï¶ùÏÑú Î∞úÍ∏â
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      REMOTE_APP_DIR: ${{ secrets.REMOTE_APP_DIR }}
      DOMAIN: ${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      # SSH Ï§ÄÎπÑ
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.GCP_SSH_KEY }}

      - name: Add GCE host to known_hosts
        run: |
          ssh-keyscan -H ${{ secrets.GCP_HOST }} >> ~/.ssh/known_hosts
          # Ï∂îÍ∞Ä Î≥¥ÏïàÏùÑ ÏúÑÌïú host key Í≤ÄÏ¶ù
          if [ -n "${{ secrets.GCP_HOST_KEY }}" ]; then
            echo "${{ secrets.GCP_HOST_KEY }}" >> ~/.ssh/known_hosts
          fi

      # Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
      - name: Test SSH connection
        run: |
          ssh -o ConnectTimeout=10 ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "echo 'SSH connection successful'"

      # ÏõêÍ≤© Ìè¥Îçî Íµ¨Ï°∞ ÏÉùÏÑ±
      - name: Ensure remote directory structure
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             echo 'Creating directories in: \$REMOTE_APP_DIR' && \
             mkdir -p \"\$REMOTE_APP_DIR\" \
                      \"\$REMOTE_APP_DIR/nginx\" \
                      \"\$REMOTE_APP_DIR/certbot/config\" \
                      \"\$REMOTE_APP_DIR/certbot/www\" \
                      \"\$REMOTE_APP_DIR/certbot/logs\" && \
             echo 'Directory structure created successfully' && \
             ls -la \"\$REMOTE_APP_DIR\""

      # .env ÌååÏùº ÏûëÏÑ± (ÌôòÍ≤ΩÎ≥ÄÏàò Ï†ÑÎã¨ ÏàòÏ†ï)
      - name: Write .env on VM
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cat > \"\$REMOTE_APP_DIR/.env\" << 'DOTENV'
          DOMAIN=${{ secrets.DOMAIN }}
          LETSENCRYPT_EMAIL=${{ secrets.LETSENCRYPT_EMAIL }}
          IMAGE_TAG=${{ github.sha }}
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          DOTENV
          echo '.env file created successfully' && \
          cat \"\$REMOTE_APP_DIR/.env\""

      # ÌîÑÎ°úÎçïÏÖòÏö© Compose & Nginx ÌÖúÌîåÎ¶ø Ï†ÑÏÜ°
      - name: Copy production assets to VM
        run: |
          export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}'
          scp docker-compose.prod.yml \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"$REMOTE_APP_DIR/"
          scp nginx/default.conf.template \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:"$REMOTE_APP_DIR/nginx/"

      # Í∏∞Ï°¥ Ïª®ÌÖåÏù¥ÎÑà Ï†ïÎ¶¨ (ÏÑ†ÌÉùÏ†Å)
      - name: Clean up old containers
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             docker compose -f docker-compose.prod.yml down --remove-orphans || true && \
             docker system prune -f --volumes || true"

      # ‚ë† Nginx + Web ÏÑ†Í∏∞Îèô (HTTP 80 Ìè¨Ìä∏ Ïó¥Í∏∞)
      - name: Start nginx & web (HTTP only)
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             source .env && \
             docker compose -f docker-compose.prod.yml pull web nginx && \
             docker compose -f docker-compose.prod.yml up -d nginx web"

      # ‚ë° Port 80 Ïó∞Í≤∞ ÌôïÏù∏ (ÏµúÎåÄ 2Î∂Ñ, Îçî Í≤¨Í≥†Ìïú Ï≤¥ÌÅ¨)
      - name: Wait until port 80 is reachable
        run: |
          echo "Waiting for HTTP service to be ready..."
          max_attempts=24
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            # Ïó¨Îü¨ ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï≤¥ÌÅ¨
            if curl -sSf -m 10 --connect-timeout 5 http://${DOMAIN} >/dev/null 2>&1 || \
               curl -sSf -m 10 --connect-timeout 5 http://${DOMAIN}/.well-known/acme-challenge/ >/dev/null 2>&1; then
              echo "‚úÖ Port 80 is reachable (attempt $attempt)"
              break
            fi
            
            echo "‚è≥ Waiting for port 80... (attempt $attempt/$max_attempts)"
            sleep 5
            attempt=$((attempt + 1))
            
            if [ $attempt -gt $max_attempts ]; then
              echo "‚ùå Port 80 not reachable after 2 minutes"
              # ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ ÏàòÏßë
              ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
                "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
                 cd \"\$REMOTE_APP_DIR\" && \
                 docker compose -f docker-compose.prod.yml logs nginx web"
              exit 1
            fi
          done

      # ‚ë¢ Certbot(webroot) Ïù∏Ï¶ùÏÑú Î∞úÍ∏â (Ïû¨ÏãúÎèÑ Î°úÏßÅ Ìè¨Ìï®)
      - name: Issue / Renew SSL certificate
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             source .env && \
             echo 'üîí Attempting to issue/renew SSL certificate...' && \
             max_cert_attempts=3
             cert_attempt=1
             
             while [ \$cert_attempt -le \$max_cert_attempts ]; do
               echo \"Certificate attempt \$cert_attempt/\$max_cert_attempts\"
               
               if docker compose -f docker-compose.prod.yml run --rm certbot \
                 certbot certonly --webroot -w /var/www/certbot \
                 --email \${LETSENCRYPT_EMAIL} \
                 -d \${DOMAIN} \
                 --agree-tos --no-eff-email --rsa-key-size 4096 \
                 --non-interactive --keep-until-expiring; then
                 echo '‚úÖ SSL certificate obtained successfully'
                 break
               fi
               
               echo \"‚ùå Certificate attempt \$cert_attempt failed\"
               cert_attempt=\$((cert_attempt + 1))
               
               if [ \$cert_attempt -le \$max_cert_attempts ]; then
                 echo '‚è≥ Retrying in 15 seconds...'
                 sleep 15
               else
                 echo '‚ùå All certificate attempts failed'
                 docker compose -f docker-compose.prod.yml logs certbot
                 exit 1
               fi
             done"

      # ‚ë£ ÏµúÏã† Ïù¥ÎØ∏ÏßÄ pull & Ï†ÑÏ≤¥ Ïä§ÌÉù Ïû¨ÏãúÏûë (HTTPS Ìè¨Ìï®)
      - name: Deploy with latest images
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
             cd \"\$REMOTE_APP_DIR\" && \
             source .env && \
             echo 'üöÄ Pulling latest images...' && \
             docker compose -f docker-compose.prod.yml pull && \
             echo 'üîÑ Restarting all services...' && \
             docker compose -f docker-compose.prod.yml up -d --remove-orphans && \
             echo '‚úÖ Deployment completed successfully'"

      # ‚ë§ Î∞∞Ìè¨ ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # HTTPS Ï≤¥ÌÅ¨
          max_attempts=12
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -sSf -m 10 --connect-timeout 5 https://${DOMAIN} >/dev/null 2>&1; then
              echo "‚úÖ HTTPS service is working (attempt $attempt)"
              break
            fi
            
            echo "‚è≥ Waiting for HTTPS service... (attempt $attempt/$max_attempts)"
            sleep 10
            attempt=$((attempt + 1))
            
            if [ $attempt -gt $max_attempts ]; then
              echo "‚ö†Ô∏è  HTTPS not immediately available, checking logs..."
              ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
                "export REMOTE_APP_DIR='${{ secrets.REMOTE_APP_DIR }}' && \
                 cd \"\$REMOTE_APP_DIR\" && \
                 docker compose -f docker-compose.prod.yml logs --tail=50"
              # HTTPS Ïã§Ìå®Ìï¥ÎèÑ Î∞∞Ìè¨Îäî ÏÑ±Í≥µÏúºÎ°ú Í∞ÑÏ£º (HTTPÎäî ÏûëÎèô Ï§ë)
              echo "‚ÑπÔ∏è  Deployment completed, but HTTPS may need more time"
              break
            fi
          done

      # ‚ë• Ï†ïÎ¶¨ ÏûëÏóÖ
      - name: Cleanup old Docker images
        run: |
          ssh ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} \
            "docker image prune -f --filter 'until=24h' || true"

  # 3) Î∞∞Ìè¨ ÏïåÎ¶º (ÏÑ†ÌÉùÏÇ¨Ìï≠)
  notify:
    needs: [build-and-push, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send deployment notification
        if: success()
        run: |
          echo "‚úÖ Deployment to ${{ secrets.DOMAIN }} completed successfully!"
          # Ïó¨Í∏∞Ïóê Slack, Discord, Ïù¥Î©îÏùº ÏïåÎ¶º Îì±ÏùÑ Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏäµÎãàÎã§
          
      - name: Send failure notification
        if: failure()
        run: |
          echo "‚ùå Deployment to ${{ secrets.DOMAIN }} failed!"
          # Ïã§Ìå® ÏïåÎ¶º Î°úÏßÅ